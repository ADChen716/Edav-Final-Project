---
title: "spotify"
author: "yp2533"
date: "2019/11/25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, out.width="100%")

library(readr)
library(tidyverse)
library(plotly)
library(knitr)
library(igraph)
library(networkD3)
library(lubridate)
library(ggplot2)
library(dplyr)
library(extracat)
library(lubridate)
library(countrycode)
library(wordcloud2)
library(tm)
library(htmlwidgets)

add_line_breaks <- function(a,n){
  a <-  str_wrap(a, width = n, indent = 0, exdent = 0)
  a <- c(paste(a, "\n"))
  return(a)
}

yearly_df <- read.csv("data/clean/yearly_data.csv", header = T)
yearly_df <- select(yearly_df, -"X")

daily_df <- read.csv("data/clean/daily_data_final.csv", header = T)
daily_df <- select(daily_df,-"X")
```

## Introduction

Spotify is an audio streaming platform, which provides access to over 50 million tracks. As of October 2019, the platform had 248 million monthly active users, including 113 million paying subscribers. Spotify offers daily ranking of songs in each region. It should be interesting if we can figure out the regular pattern of people listening to songs.

We want to explore the following four aspects:

- Are there any trends of songs' steams over time?

- Do people show special preference to some audio features?

- Is there anything thought-provoking for singers? For example, do they have some genres? Or do they share some similarties with other singers?

- What about the lyrics? Are there any interesting common words for different songs?

## Data sources

We are using open-source data from Spotify, and collecting the features of each song using its API. We get the list of the songs to focus on by scraping data from spotifychart (https://spotifycharts.com/regional) which contains the daily top 200 songs.

We also managed to get the information of top songs by each country using the crawler. However, since the data for some countries are missing, we are still discussing about the ways to handle it, such as focusing only on the continents with enough data.

Besides, we got the connection between singers using `related-artists` from Spotify. Due to the large amount of artists, we only selected top 100 singers as our dataset and studied their network.

Since Spotify itself does not offer us track lyrics, we scraped lyrics from Ginus. But we don't know the track ID in Ginus, so we have to use track name and artist name to match a song and get its lyrics. This is not an exact search, and many songs can not be matched, causing several missing content of lyrics. To solve this problem, we only care about those songs that we can successfully get their lyrics.

Also, due to the size of the dataset (there are too many songs right now!), it would be impossible to carefully analyze every song on the list. We plan to focus on the top songs and the most popular singers.

Yichi Liu collected the daily ranking data of different countries, Rui Bai collected connections between artists, and Yuchen Pei collected lyrics of top songs.

- Daily ranking data: 2837664 records of 23 variables.
  
  - Factor: `track_id`, `Track.Name`, `Artist`, `Date`, `Region`, `artists`, `artists_IDs`, `Artist_ID`.
  - Int: `Position`, `Streams`, `key`, `mode`, `duration_ms`, `time_signature`
  - Num: `danceability`, `energy`, `loudness`, `speechiness`, `acousticness`, `instumentalness`, `liveness`, `valence`, `tempo`.
  
- Yearly ranking data: 6300 records of 22 variables.

  - Factor: `track_id`, `Track.Name`, `Artist`, `Region`, `artists`, `artists_IDs`, `Artist_ID`.
  - Int: `Position`, `Streams`, `key`, `mode`, `duration_ms`, `time_signature`
  - Num: `danceability`, `energy`, `loudness`, `speechiness`, `acousticness`, `instumentalness`, `liveness`, `valence`, `tempo`.
  
- Global singer connection: an adjacency Matrix with 67 nodes.
- Lyrics: 1552 records of 2 variables.
  
  - Char: `id`, `lyric`.

## Obstacle 

Our raw data are quite messy. One song may have multiple track ids for different albums. Even the same album might be multi-labeled. Hence, we need to locate the data by both "artist name" and "track name" instead of id. Moreover, since Spotify records songs from all over the world, there are many Greek characters and many other languages in track names and artist names. This is problematic when we scraped other information based on the track name and artist name. Those characters would cause meaningless word clouds in our further analysis. We tried to scrape the data based on their ids. We also substituted Greek characters with English characters instead and dropped the data that are meaningless.

## Data Transformation

### Get Features

After scraping the daily data from [Spotify Charts](https://spotifycharts.com/regional), there are only information about the track name, track id and artists. We wanted to get more information behind the songs. For each song, we crawled its feature by the track id.

Also, since there are many collaboration songs, `artist_id` may be ids for all of the singers. We filtered out the id for the main artist.

### Get Yearly Data
We want to generate a yearly ranking of the songs in different countries during a year. The existing charts like Billboard and playlists for the top songs in Spotify are for 2018. Since we are already at the end of 2019, we want to get the latest one. So we added up the daily streams of each song and ordered them by its total stream.

### Get Lyrics
Since Spotify itself does not offer us track lyrics, we need to scrape lyrics by track name and artist from Ginus. However, there are too many non-English characters in track names or artist names, so we first replace them with corresponding English characters and then drop additional information between parentheses or after horizontal bars. 

After we successfully scrape the lyrics line by line using `genius_lyrics`, we merged these lines into one line that contains the whole lyrics and wrote it into a csv file.

## Missing Values
```{r}
# Daily missing pattern
visna(daily_df, sort = "b")
```
For daily data, most of the data have no missing value. However, Some of the data have no track name or artist_id. Since we obtained the data from the website, it’s important to figure out why the missing value exists. For the missing `track_id` data, there was 2 of them and we could not generate its features by its id as usual. We checked the original website and found that there was exactly blank ranking on it. Some of the data don’t have information of track name because of the website error so that we could not locate the songs for further analysis. We dropped those data. For those have only missing information we don’t care, such as "artist_id", we kept them.

## Data Overview
We used the global yearly ranking data(Top 100 from Nov.1 2018 to Oct.31 2019) to get an overview of the most popular songs and singers during this period.

- Top songs
  
  After summing up the daily streams of each songs, we got the top 10 songs as follows.
  
  This table shows that Sunflower, an episode of the movie Spider-Man: Into the Spider-Verse, ranked first. This movie is the first animated feature film in the Spider-Man franchise. Once the film released on Dec.14 2018, it received praise worldwide for its animation, characters, story, voice acting, humor and soundtrack. So it is no surprise that Sunflower was so popular last year.
  
  From the table, we can also find that all of the top 10 songs recieved over 700 million streams last year. This huge number indicates that Spotify should have a large group of loyal users. 

```{r}
global_yearly_data <- subset(yearly_df, Region == "global")

top10_tracks <- select(global_yearly_data, c("yearly_rank", "Track.Name", "Artist", "total_stream")) %>%
  subset(yearly_rank <= 10)
colnames(top10_tracks) <- c("Rank", "Track", "Artist", "Stream")
rownames(top10_tracks) <- NULL
kable(top10_tracks)
```

  Let's consider top songs from another angle. If one song stayed on the ranking for a long time, it should also be a popular song. We calculated the number of days each song on the ranking using the global daily dataset and drew a cleveland plot. Since we only cared about "top" songs, we dropped those songs which stayed on the ranking for less than 100 days.
  
  From this plot we can conclude that there were 23 songs that stayed in Global Top 100 for the last whole year. Although few of them had a high ranking, they are still enduring and popular songs.
  
```{r}
global_daily_data <- subset(daily_df,  Region == "global")

global_daily_data$Track <- sub("(\\(|-).*$", "", as.character(global_daily_data$Track.Name))
days_of_songs <- global_daily_data %>% 
  group_by(Track) %>% 
  distinct(Date) %>%
  dbplyr::summarise(Freq = n()) %>%
  arrange(-Freq) %>%
  subset(Freq > 100)

plot_ly(days_of_songs, x = ~Freq, y = ~reorder(Track,Freq), type = 'scatter',
        mode = "markers", marker = list(color = "blue")) %>%
  layout(
    title = "How long are these songs staying in Global Top 100?",
    xaxis = list(title = "Number of days in Global Top 100"),
    yaxis = list(title = "Track")
  )
```

- Top singers
  
  We have already found that Post Malone and Ariana Grande both had two songs among the top 10. Would they also be the most popular singers last year? 
  
  On the Top 100 ranking, there were 67 singers in total. We defined top singers as those artists who had more than one popular songs and drew a barchart for them.
  
```{r}
# singers who have more than one songs on the ranking
singers <- global_yearly_data %>%
  group_by(Artist) %>%
  dbplyr::summarise(Count = n())
top_singers <- subset(singers, Count > 1)

# draw a barchart to have an overview of top singers
plot_ly(top_singers, x=~reorder(Artist, -Count), y=~Count, type="bar") %>%
  layout(title = "Top singers",
  xaxis = list(title = "Artist"),
  yaxis = list(title = "Count of songs on the ranking"))
```
  
  Among the 17 top singers, 7 of them only had two very popular songs. The most popular artist is Post Malone, who had 6 songs on the ranking. And three artists, Billie Eilish, Ed Sheeran and XXXTENTACION, each had 4 songs on the ranking.
  
  It is intersting to found that though Ariana Grande had two super pop songs, the number of her songs on the ranking was not the most. Therefore, when we consider whether an artist is hot, we should not only depend on how popular his works are but also how many popular works he has.
  
  For further investigation, we picked 4 singers who had at least four songs on the ranking. They are: Post Malone, Billie Eilish, Ed Sheeran and XXXTENTACION.
  
  Similarly, we studied the total number of days of each artist on the daily ranking last year. 25 singers stayed on the ranking for the whole year, including those 4 top singers we discussed above. Now it should be safer to draw the conclusion that these people are indeed the most popular and loved singers worldwide.
  
```{r}
days_of_singers <- global_daily_data %>% 
  group_by(Artist) %>% 
  distinct(Date) %>%
  dbplyr::summarise(Freq = n()) %>%
  arrange(-Freq) %>%
  subset(Freq > 100) %>%
  dbplyr::mutate(Artist = as.character(Artist))

plot_ly(days_of_singers, x = ~Freq, y = ~reorder(Artist,Freq), type = 'scatter',
        mode = "markers", marker = list(color = "blue")) %>%
  layout(
    title = "How long are these singers staying in Global Top 100?",
    xaxis = list(title = "Number of days in Global Top 100"),
    yaxis = list(title = "Artist")
  )
```

## Data Understanding

Before we start analyze our data, we first need to understand the meaning of each audio feature. Explanations are from (https://developer.spotify.com/documentation/web-api/reference/object-model/#audio-features-object).

- `acousticness`: A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic.

- `danceability`: Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable.

- `energy`: Energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. 

- `instrumentalness`: Predicts whether a track contains no vocals. "Ooh" and "aah" sounds are treated as instrumental in this context. The closer the instrumentalness value is to 1.0, the greater likelihood the track contains no vocal content. Values above 0.5 are intended to represent instrumental tracks, but confidence is higher as the value approaches 1.0.

- `liveness`: Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides strong likelihood that the track is live.

- `loudness`: The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typical range between -60 and 0 db.

- `speechiness`: Speechiness detects the presence of spoken words in a track. The more exclusively speech-like the recording, the closer to 1.0 the attribute value. Values above 0.66 describe tracks that are probably made entirely of spoken words. Values between 0.33 and 0.66 describe tracks that may contain both music and speech, either in sections or layered, including such cases as rap music. Values below 0.33 most likely represent music and other non-speech-like tracks.

- `tempo`: The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.

- `valence`: A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).


## Results

### Streams Trend

To get an overview understanding of the data, it is important to find out how many songs people listen every day. Since we could not get the actual daily total streams among all songs, we computed the total stream for the top 200 songs each day. The top songs are representative songs that people listened and the major components of the actual streams. Hence, it’s reasonable for the simulation.

```{r, include=FALSE}
global_daily_df <- daily_df[daily_df$Region=="global",]
global_daily_df$Date<-  as.Date(global_daily_df$Date)

global_total_daily_df <- global_daily_df %>%
  group_by(Date) %>%
  dbplyr::summarize(total_listening = sum(Streams)) %>%
  ungroup()%>%
  arrange(Date)

plot_ly(global_total_daily_df ,x = ~Date, y = ~total_listening, mode = 'lines') %>%
  layout(title = "Daily total listening",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Streams"))

ggplot(global_total_daily_df, aes(Date, total_listening)) +
  geom_line() +
  geom_smooth(method = "loess", se = FALSE, lwd = 1.5) +
  facet_grid(.~wday(Date, label = TRUE))
```

As shown in graph above, there is a clear circular trend. By moving the mouse on the line, we could find that the differences between local peaks are always 7days, which reminds us about a weekly trend. Faceting by weekdays, the average total streams is much higher on Friday than Sunday. Also, the average is rising during the weekdays and dropping on weekends. This shows that people prefer to listen to music during weekdays, especially Friday, while their preference to music is lower on weekends. 

This looks surprising at the first glance that people should preferred to enjoy themselves at weekends, for example, by listening to music. However, in weekends, a great amount of choices for relaxation are given to people. They could use the entire spare time to go camping, watch movies and spend time with family and friends. Actually, people’s desire for relaxation remains the same in weekdays. But the only free time they get is that on traffics, which is fragmentary to use. Listening to music seems the best way for them to relax. Also, there might be early-Friday for some companys. So there exists a clear peak for Friday.

Furthermore, although seasonal preference to music does not exist in the graph, the total streams for Dec 24th, which is Christmas Eve, are extremely higher than others. The special trend does not appear in any other festival. Why Christmas Eve is an exception? Many famous Christmas songs come to our mind. Christmas is a festival of songs! To verify our hypothesis, we took a look at the top songs at Christmas Eve.

```{r}
global_daily_df <- subset(daily_df, Region == "global")
global_christmas_data <- global_daily_df[which(global_daily_df$Date=="2018-12-24"),]%>%
  arrange(Position)
top10_tracks <- select(global_christmas_data, c("Position", "Track.Name", "Artist", "Streams")) %>%
  subset(Position <= 10)
colnames(top10_tracks) <- c("Rank", "Track", "Artist", "Streams")
rownames(top10_tracks) <- NULL
kable(top10_tracks)
```

Most of the top songs are songs for Christmas. Christmas could remind people of those songs, which contributes to the high streams.

#### Popularity trend

<iframe src="d3/dailyTopSong.html" width="950" height="550"></iframe>

Regardless of the overall trend, is there any typical popularity trends once a song is on board? We drew line chart for the streams v.s. the days since it is on board. By clustering by trend, we concluded that there are 3 types of popular songs and we drew the trend for one typical song in each group.

```{r}
global_daily_df <- daily_df[which(daily_df$Region=="global"),]
global_daily_df$Date<-  as.Date(global_daily_df$Date)
global_daily_df <-global_daily_df %>%
  arrange(Date)%>%
  group_by(Track.Name) %>%
  complete(Date = seq.Date(min(Date), max(Date), by="day"))%>%
  ungroup()

global_yearly_df <- yearly_df[which(yearly_df$Region == "global"),]%>%
  arrange(yearly_rank)

# top 50
global_top_daily_df <- left_join(global_yearly_df[1:50,c("Track.Name","Artist","total_stream","yearly_rank")], global_daily_df, by=c("Track.Name","Artist"))

track <- "thank u, next"
p1 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~Streams, type = "scatter", mode = "lines",name = ~"streams")
p2 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~ Position, type = "scatter", mode = "lines", name = ~"rank")%>%
  layout(yaxis = list(autorange = "reversed"))
subplot(p1,p2) %>%
  layout(title="Falling: thank u, next--Ariana Grande" )

track <- "Wow."
p1 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~Streams, type = "scatter", mode = "lines",name = ~"streams")
p2 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~ Position, type = "scatter", mode = "lines", name = ~"rank")%>%
  layout(yaxis = list(autorange = "reversed"))
subplot(p1,p2) %>%
  layout(title="Up and down: Wow.--Post Malone" )

track <- "Dance Monkey"
p1 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~Streams, type = "scatter", mode = "lines",name = ~"streams")
p2 <- plot_ly(global_top_daily_df[which(global_top_daily_df$Track.Name==track),], x = ~Date, y = ~ Position, type = "scatter", mode = "lines", name = ~"rank")%>%
  layout(yaxis = list(autorange = "reversed"))
subplot(p1,p2) %>%
  layout(title="Rising: Dance Monkey--Tones and I" )
```

* Type 1: falling. Those songs were listened the most when they were just on board. Their ranking fell as time goes by. The popularity of those songs is usually related to the reputation of the artist.

* Type 2: rising before falling. Those songs are good waiters. Also, they ranked high on the chart for a long time. This might because the songs are in good quality. Regardless of the effect of singers, people just loved the songs.

* Type 3: rising. The total streams of those songs kept rising. And the rank of those songs moved to top and stayed on the top. Although they were not expected as a great song, its great melody engages people.

As concluded above, there is no strict popularity trend for a song. Some of them are popular at the beginning and fall soon while some of them are preferred by more and more people. It’s all about the quality of the song. So don’t be sad if the song is not popular at once and don’t be overconfident that the song will always be popular!

### Feature Analysis

#### Distribution of features

In order to analyze track features, we first need to know the distribution of each feature. Spotify offers us nine different continuous track features: `danceability`, `energy`, `loudness`, `speechiness`, `acousticness`, `instrumentalness`, `liveness`, `valence`, `tempo`. We used `scale()` to center the features so that they should have the same scale then. The following boxplot shows their distribution. 

It is clear that danceability, duration_ms, energy, loudness, tempo and valence were approximately evenly distributed around 0, which means people didn't show special preference for these features. Acousticness, liveness and speechiness all had a mean below 0, along with some outliers, indicating that generally people prefer songs with low value of these features, but it does not necessarily mean that more lively songs could not be popular. 

For instrumentalness, we found that most of its values were below 0, while some were very large. By recalling its definition--a predictor of whether a track contains no vocals, our finding can be explained because it's normal that most of popular songs contain vocal content, resulting in low instrumentalness, and those outliers represent popular instrumental tracks.

```{r}
# standardize features that are continuous 
feature_name = c("danceability", "energy", "loudness", "speechiness", "acousticness",
                 "instrumentalness", "liveness", "valence", "tempo")
standardized_feature <- data.frame(scale(global_yearly_data[, feature_name]))

# draw a boxplot to have an overview of the track features
features <- gather(standardized_feature, "feature", "value")
plot_ly(features, y = ~value, x = ~reorder(features$feature, -features$value, FUN = median), type = "box") %>%
            layout(xaxis = list(title = "Song Feature"),
                   yaxis = list(title = "Standardized Value"))
```


#### Feature correlation

We are curious about whether there exists some correlationship between each pair of these features, so we calculated their correlationship matrix and then drew a heatmap. It's easy to find that only loudness and energy have a significantly positive correlationship with coefficient 0.763 while other features seem to be not correlated.

Moreover, we are insterested in the influence of features on the ranking of a track. From the heatmap, we may conclude that value of these features has nothing to do with  yearly rank. This finding is really useful because now that people don't have preference about the track features, they don’t need to deliberately change their style to cater to the public.

```{r}
global_yearly_feature <- select(global_yearly_data, c(unlist(feature_name), "yearly_rank"))

m <- cor(global_yearly_feature)
plot_ly(x = c(unlist(feature_name), "yearly_rank"),
        y = c(unlist(feature_name), "yearly_rank"),
        z = m,
        zmin = -1,
        zmax = 1,
        type = "heatmap")
```

#### Feature time series

Line chart for each feature is drawn over the year after rescaling to make each start from 100.

```{r}
global_daily_df <- daily_df[daily_df$Region=="global",]
global_daily_df$Date<-  as.Date(global_daily_df$Date)

daily_average_feature <- global_daily_df %>%
  group_by(Date) %>%
  dbplyr::summarise(danceability = mean(danceability),
            energy = mean(energy),
            loudness = mean(loudness),
            speechiness = mean(speechiness),
            acousticness = mean(acousticness),
            instrumentalness = mean(instrumentalness),
            liveness = mean(liveness),
            valence = mean(valence),
            tempo = mean(tempo)
            #duration_ms = mean(duration_ms)
            ) %>%
  ungroup()

daily_average_feature <- daily_average_feature %>%
  gather(key = "feature", value = value, -Date) %>%
  group_by(feature) %>%
  dbplyr::mutate(rescaled_value = 100* value/value[1])

plot_ly(daily_average_feature, x = ~Date, y = ~ rescaled_value, color = ~feature, mode = 'lines') %>%
  layout(title = "Trend of tastes",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Feature Value"))
```

The plot indicated an obvious exception on Dec 25th, 2018. On that day, people preferred songs with high acousticness, loudness and low dancability, energy and speechiness. Since it is mentioned that the loudness is positively related to energy, the result looks weird. As mentioned before, people loved Christmas songs on Christmas, for example, "White Christmas", "It's Beginning to Look a Lot like Christma". We checked the features for the Christmas songs and found that those songs have the special features as mentioned. 

#### Features world map

The distribution of the features also varies between countries. Comparing the distribution of dancability and liveness, although people in Brazil do not prefer songs that are more suitable for dance, they love live music. Also, based on the distribution of valence and energy, South American people love positive and intensive songs more than North American people. Turkish people preferred instrumental music than spoken word musics.

```{r}
yearly_map_df <- subset(yearly_df, Region!="global")
yearly_map_df$country_code <- countrycode(toupper(yearly_map_df$Region),origin = 'iso2c',destination = 'iso3c')


g <- list(
  showframe = FALSE,
  showcoastlines = FALSE,
  projection = list(type = 'Mercator')
)

plot_df <- aggregate(yearly_map_df[, c("danceability","energy","loudness","speechiness",
                                       "acousticness","instrumentalness","liveness" ,
                                       "valence","tempo")], 
                     list(yearly_map_df$country_code), mean)
plot_df$country_name <- countrycode(plot_df$Group.1,origin = 'iso3c',destination = 'country.name')
l <- list(color = toRGB("grey"), width = 0.5)
plot_geo(plot_df) %>%
  add_trace(
    z = plot_df$instrumentalness, color = plot_df$instrumentalness, colors = 'Blues',
    text = ~country_name, locations = ~Group.1, marker = list(line = l)
  ) %>%
  colorbar(title = '', tickprefix = '') %>%
  layout(
    title = 'Average song features by country',
    geo = g,
    margin = list(l=30)
    )
```

In total, although features have no direct correlation with the ranking, different song features are preferred at different time points and different countries.

### Singers Deep Dive

#### Genre of a singer
After standardizing the features, we got the radarchart of every singers as follows. 

It's easy to find that all their songs had low instrumentalness except for Billie Eilish's "Bad Guy" and "Bury a Friend". 

Post Malone's songs had high loudness, energy and dancebility. Unlike his other songs, Wow had relativily high speechiness since it is a rap song. And since Sunflower is a cooperative song, if we ignore its incluence, we can see that the valence of his songs is not very high. 

Ed Sheeran's songs had high loudness, energy and dancebility and low tempo and liveness. Except for "Shape of you", his top songs had low acousticness. The valence of "Perfect" is low for that it was a romantic ballad written about his fiancée.

The radarchart of Billie Eilish is very interesting since featurs of her different songs varied. The four songs all had a tempo within the medium range. "Wish you were a gay" is a song with extremely high danceability and liveness. "When the party's over" is a song with extremely high acousticness and low liveness, energy, loudness. "Bury a friend" had high acousticness, speechiness and instrumentalness. "Bad guy" had high speechiness and relatively high valence. It indicates that Billie Eilish' songs were not limited to one particular style.

For XXXTENTACION, features of his songs were somehow like those of Post Malone. His songs had relatively high loudness, energy, danceability. Tempo of his songs was not very high but speechiness was high.

```{r, out.width="100%"}
global_yearly_data$Track.Name <- add_line_breaks(global_yearly_data$Track.Name, 20)

fn <- function(x) (x-min(x)) * 100 / (max(x)-min(x))
std_global_yearly_data <- data.frame(lapply(global_yearly_data[, feature_name], fn))
std_global_yearly_data$Track <- global_yearly_data$Track.Name
std_global_yearly_data$Region <- global_yearly_data$Region
std_global_yearly_data$Artist <- global_yearly_data$Artist

PM_tracks <- subset(std_global_yearly_data, Artist == "Post Malone")
plot_ly(
  type = 'scatterpolar',
  fill = 'toself',
  mode = "markers"
) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[1,1:9])), PM_tracks[1,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[1, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[2, 1:9])), PM_tracks[2,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[2, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[3, 1:9])), PM_tracks[3,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[3, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[4, 1:9])), PM_tracks[4,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[4, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[5, 1:9])), PM_tracks[5,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[5, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(PM_tracks[6, 1:9])), PM_tracks[6,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = PM_tracks[6, "Track"]
  ) %>%
  layout(
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0,100)
      )
    )
  )

ES_tracks <- subset(std_global_yearly_data, Artist == "Ed Sheeran")
plot_ly(
  type = 'scatterpolar',
  fill = 'toself',
  mode = "markers"
) %>%
  add_trace(
    r = c(unlist(matrix(ES_tracks[1,1:9])), ES_tracks[1,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = ES_tracks[1, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(ES_tracks[2, 1:9])), ES_tracks[2,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = ES_tracks[2, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(ES_tracks[3, 1:9])), ES_tracks[3,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = ES_tracks[3, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(ES_tracks[4, 1:9])), ES_tracks[4,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = ES_tracks[4, "Track"]
  ) %>%
  layout(
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0,100)
      )
    )
  )

BE_tracks <- subset(std_global_yearly_data, Artist == "Billie Eilish")
plot_ly(
  type = 'scatterpolar',
  fill = 'toself',
  mode = "markers"
) %>%
  add_trace(
    r = c(unlist(matrix(BE_tracks[1,1:9])), BE_tracks[1,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = BE_tracks[1, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(BE_tracks[2, 1:9])), BE_tracks[2,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = BE_tracks[2, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(BE_tracks[3, 1:9])), BE_tracks[3,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = BE_tracks[3, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(BE_tracks[4, 1:9])), BE_tracks[4,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = BE_tracks[4, "Track"]
  ) %>%
  layout(
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0,100)
      )
    )
  )

XX_tracks <- subset(std_global_yearly_data, Artist == "XXXTENTACION")
plot_ly(
  type = 'scatterpolar',
  fill = 'toself',
  mode = "markers"
) %>%
  add_trace(
    r = c(unlist(matrix(XX_tracks[1,1:9])), XX_tracks[1,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = XX_tracks[1, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(XX_tracks[2, 1:9])), XX_tracks[2,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = XX_tracks[2, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(XX_tracks[3, 1:9])), XX_tracks[3,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = XX_tracks[3, "Track"]
  ) %>%
  add_trace(
    r = c(unlist(matrix(XX_tracks[4, 1:9])), XX_tracks[4,1]),
    theta = c(unlist(feature_name), feature_name[1]),
    name = XX_tracks[4, "Track"]
  ) %>%
  layout(
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0,100)
      )
    )
  )
```

#### Reason for songs to get popular

The songs of the top singers are great examples to explore the specific peaks in the streams for the songs. We drew the time series for those who own the most top 100 songs in the year. The trends of streams for each song are shown in the graph.  

```{r}
global_daily_df <- daily_df[daily_df$Region=="global",]
global_daily_df$Date<-  as.Date(global_daily_df$Date)
singer_daily_df <- global_daily_df[which(global_daily_df$Artist=="Post Malone"),] %>%
  arrange(Date)%>%
  group_by(Track.Name) %>%
  complete(Date = seq.Date(min(Date), max(Date), by="day"))%>%
  ungroup()
  
  
a <- list(text = "Movie 'Spider-Man' is on!",
  showarrow = TRUE,
  arrowhead = 1,
  x = as.Date("2018-12-14"),
  y = 4e6
)
b <- list(text = "3rd album is out!",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-09-06"),
          y = 7.3e6
)
plot_ly(singer_daily_df ,x = ~Date, y = ~ Streams, color = ~Track.Name, mode = 'lines') %>%
  layout(title = "Popularity of Post Malone",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Streams"),
         annotations = list(a,b))



# Billie Eilish
singer_daily_df2 <- global_daily_df[which(global_daily_df$Artist=="Billie Eilish"),] %>%
  arrange(Date)%>%
  group_by(Track.Name) %>%
  complete(Date = seq.Date(min(Date), max(Date), by="day"))%>%
  ungroup()

a <- list(text = "New single is out!",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-02-01"),
          y = 5.56e6
)
b <- list(text = "New album is out!",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-03-29"),
          y = 7e6
)
c <- list(text = "A new concert at CA",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-07-11"),
          y = 6.25e6
)
plot_ly(singer_daily_df2 ,x = ~Date, y = ~ Streams, color = ~Track.Name, mode = 'lines') %>%
  layout(title = "Popularity of Billie Eilish",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Streams"),
         annotations = list(a,b,c))



# Ed Sheeran
singer_daily_df3 <- global_daily_df[which(global_daily_df$Artist=="Ed Sheeran"),] %>%
  arrange(Date) %>%
  group_by(Track.Name) %>%
  complete(Date = seq.Date(min(Date), max(Date), by="day"))%>%
  ungroup()

a <- list(text = "Collaboration with Justin Bieber \n after 'Love Yourself' 4 years ago",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-05-10"),
          y = 11e6
)
b <- list(text = "New album is out!",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2019-07-12"),
          y = 6.3e6
)

plot_ly(singer_daily_df3 ,x = ~Date, y = ~ Streams, color = ~Track.Name, mode = 'lines') %>%
  layout(title = "Popularity of Ed Sheeran",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Streams"),
         annotations = list(a,b))

# XXXTENTACION
singer_daily_df4 <- global_daily_df[which(global_daily_df$Artist=="XXXTENTACION"),] %>%
  arrange(Date) %>%
  group_by(Track.Name) %>%
  complete(Date = seq.Date(min(Date), max(Date), by="day"))%>%
  ungroup()

a <- list(text = "New album is out!",
          showarrow = TRUE,
          arrowhead = 1,
          x = as.Date("2018-12-07"),
          y = 3.56e6
)

plot_ly(singer_daily_df4 ,x = ~Date, y = ~ Streams, color = ~Track.Name, mode = 'lines') %>%
  layout(title = "Popularity of XXXTENTACION",
         xaxis = list(title = "Date"),
         yaxis = list (title = "Streams"),
         annotations = a)
```

* Post Malone: In the graph there are two significant peaks. To find out why the peaks exist, we searched about the date and the song. On Dec 14th, 2018, the movie: Spider-Man: Into the Spider-Verse was on while one of its tracks: "Sunflower" was played more than normal. On Sep 6th, 2018, he released a new album "Hollywood’s Bleeding" and included several existing popular songs while there was a great peak on that day.

* Billie Ellish: There are three significant peaks. On Feb 1st, 2019 and March 29th, 2019, she released a new single and album: "bury a friend",  "When We All Fall Asleep, Where Do We Go?" which contributed to the two peaks, respectively. There was also a peak on July 11st, 2019 without new album. Actually, she held a concert in CA so that people might be engaged by her voice.

* Ed Sheeran: Songs like "Shape of You" and "Perfect" were always on chart. They were released years ago, which means they are songs people always like. May 10th, 2019 was a great peak. On that day, the song "I Don’t care" was released which was a second collaboration with Justin Bieber after 4 years. They are both famous singers and the collaboration was expected by fans for a long time, which caused a high rise. Also, as happened to others, the streams popped when his new album was out on July 12nd.

*	XXXTENTACION: As mentioned before, peak appeared when he released a new album. 

In total, the popularity of songs is triggered by events. Big events contribute to a sudden rise of the streams. 



#### Singer network

Spotify offers us an API to get an artist's related artists. Similarity is based on analysis of the Spotify community’s listening history. We scraped such information of our top singers in global yearly top 100 and based on this, constructed a network of these artists.

We found that many singers do not share similarity with other top singers. For example, BTS does not connect to any other artists in this network, which means people who like to listen BTS's songs are not tend to listen songs from other singers on the top ranking. We have 15 such "lonely" singers, while others form several clusters with different colors in the network. Users that prefer Ed Sheeran's songs may also like listening Taylor Swift or James Arthur. Maluma, Ozuna, Lunay, Jhay Cortez and Dalex share relatively high similarity with each other.

```{r}
artist_df <- read.csv("data/clean/singer_connection/global.csv", header = T)
row.names(artist_df) <- artist_df$X
artist_mat <- select(artist_df, -"X") %>%
  as.matrix()

network <- graph_from_adjacency_matrix(artist_mat, weighted=T, mode="undirected", diag=F)
wc <- cluster_walktrap(network)
members <- membership(wc)
netword_d3 <- igraph_to_networkD3(network, group = members)
forceNetwork(Links =netword_d3$links, Nodes = netword_d3$nodes, 
             Source = 'source', Target = 'target',
             NodeID = 'name', Group = 'group',
             linkDistance = 30, fontSize = 20, 
             opacity = 0.8, charge = -5)
```

### Hey lyrics

Another interesting component of songs is the lyrics. We are interested in what different types of songs are talking about, and thus we explored this topic by visualizing the frequent words in word cloud format. 

We have created an interactive word cloud (available in Shiny App) in which users have control over what songs to visualize by selecting ranges of three song features, i.e. danceability, energy, and loudness. Some other song features are not included due to their irrelevance to lyrics theme. For example, instrumentalness is not included since songs with different instrumentalness naturally have difference in lyrics lengths instead of lyrics content. 
By playing around with the sliders, we have some interesting findings. For example, if we change the danceability slider to high and low, we can get the two clouds below.

* For songs with high danceability (above 0.816):

```{r}
lyrics_df <- read.csv("data/clean/lyrics_eng_merged.csv")
stop_words <- read.csv("data/clean/stop_words.csv")
stop_words <- as.character(stop_words$stop_word)

filtered_df_low <- subset(lyrics_df, danceability <= 0.556)
filtered_df_high <- subset(lyrics_df, danceability >= 0.816)

get_cloud_df <- function(df){
    
    lyrics_corpus = Corpus(DataframeSource(df[,c("doc_id","text")]))
    
    lyrics_corpus = tm_map(lyrics_corpus, content_transformer(tolower))
    lyrics_corpus = tm_map(lyrics_corpus, removeNumbers)
    lyrics_corpus = tm_map(lyrics_corpus, removePunctuation)
    lyrics_corpus = tm_map(lyrics_corpus, removeWords, c(stop_words, stopwords("spanish")))
    lyrics_corpus =  tm_map(lyrics_corpus, stripWhitespace)
    
    lyrics_dtm <- DocumentTermMatrix(lyrics_corpus)
    
    lyrics_dtm = removeSparseTerms(lyrics_dtm, 0.95)
    
    get_freq_df <- data.frame(colSums(as.matrix(lyrics_dtm)))
    freq = data.frame(word = rownames(get_freq_df),freq = get_freq_df[,1])
    
    sorted <- freq[order(-freq$freq),][c(1:50),]
    return(sorted)
}
    

wordcloud2(data=get_cloud_df(filtered_df_high),color = "random-dark",size=0.8)

```

We can see that many of the frequent words (with larger sizes) are swear words, which has a significant difference compared to songs with lower danceability (we will show later). We suspect that the songs selected are mostly hip-hop songs, since they naturally have higher danceability. Thus, our hypothesis is that hip-hop songs are more likely to contain profanities than others, which we will test out in later sections.

* For songs with low danceability (below 0.556):

```{r}

hw = wordcloud2(data=get_cloud_df(filtered_df_low),color = "random-dark",size=0.7)
saveWidget(hw,"1.html",selfcontained = F)
webshot::webshot("1.html","1.png",vwidth = 700, vheight = 500, delay =10)

```

When selecting songs with lower danceability, the resulted frequent words in the cloud are more gentle and somewhat story-telling, such as "heart" and "love". One possibility is that many songs with lower danceability tend to be softer with romantic themes.

Thus, we can see that songs with different feature ranges indeed have differet content.

In order to further explore the differences in lyrics for different song themes, we have plotted the word clouds for four different playlists, including: 

* Christmas playlist
```{r}

webshot::install_phantomjs()

christmas <- read.csv("data/clean/christmas.csv")
hw = wordcloud2(data=christmas,color = "random-dark",size=0.6)
saveWidget(hw,"1.html",selfcontained = F)
webshot::webshot("1.html","1.png",vwidth = 700, vheight = 500, delay =10)
# wordcloud2(data=christmas,color = "random-dark",size=0.6)

```

* Halloween playlist
```{r}

halloween <- read.csv("data/clean/halloween.csv")
hw = wordcloud2(data=halloween,color = "random-dark",size=0.8)
saveWidget(hw,"1.html",selfcontained = F)
webshot::webshot("1.html","1.png",vwidth = 700, vheight = 500, delay =10)

```


* hip-hop playlist
```{r}

hiphop <- read.csv("data/clean/hiphop.csv")
hw = wordcloud2(data=hiphop,color = "random-dark",size=0.9)
saveWidget(hw,"1.html",selfcontained = F)
webshot::webshot("1.html","1.png",vwidth = 700, vheight = 500, delay =10)

```

* Romance playlist
```{r}

romance <- read.csv("data/clean/romance.csv")
hw = wordcloud2(data=romance,color = "random-dark",size=1)
saveWidget(hw,"1.html",selfcontained = F)
webshot::webshot("1.html","1.png",vwidth = 700, vheight = 500, delay =10)

```

By simple comparison, we can see that different song themes indeed have different lyrics content. It is under expectation for Christmas songs to have frequent words such as "bells", "santa", and "snow". Similarly, for Halloween playlist, we can see frequent words including "monster" and "night", which are indeed horror-related.

Also, for songs with a romantic theme, they tend to have soft and sweet words such as "love", "baby", "heart" and "kiss", this is similar to songs with lower danceability as we have shown above. On the contrary, the hip-hop songs are again full of bad language, which is quite similar to what we discovered in songs with high danceability, and it has verified our hypothesis that songs with higher danceability are likely to be the hip-hop songs containing a large amount of swear words.
